<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">

<!--Converted with LaTeX2HTML 2002-2-1 (1.70)
original version by:  Nikos Drakos, CBLU, University of Leeds
* revised and updated by:  Marcus Hennecke, Ross Moore, Herb Swan
* with significant contributions from:
  Jens Lippmann, Marek Rouchal, Martin Wilck and others -->
<HTML>
<HEAD>
<TITLE>chana091040</TITLE>
<META NAME="description" CONTENT="chana091040">
<META NAME="keywords" CONTENT="chana091040">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">

<META NAME="Generator" CONTENT="LaTeX2HTML v2002-2-1">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">

<LINK REL="STYLESHEET" HREF="chana091040.css">

<LINK REL="next" HREF="node1.html">
</HEAD>

<BODY >
<!--Navigation Panel-->
<A NAME="tex2html2"
  HREF="node1.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next"
 SRC="file:/usr/share/latex2html/icons/next.png"></A> 
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up"
 SRC="file:/usr/share/latex2html/icons/up_g.png"> 
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous"
 SRC="file:/usr/share/latex2html/icons/prev_g.png">   
<BR>
<B> Next:</B> <A NAME="tex2html3"
  HREF="node1.html">About this document ...</A>
<BR>
<BR>
<!--End of Navigation Panel-->
<DIV ALIGN="CENTER">
  <FONT SIZE="+1">Mathieu Chanaud 
<BR><B>A dedicated method for solving large linear systems arising from finite element discretizations of high-frequency Maxwell problems. </B></FONT>
</DIV>
<P>
<DIV ALIGN="CENTER">INRIA Bordeaux Sud-Ouest and LaBRI 
<BR>
Universit&#233; de Bordeaux 
<BR>
Talence 
<BR>
France

<BR><TT>chanaud@labri.fr</TT>
<BR>
David Goudin
<BR><EM>CEA/CESTA, BP 2, 33114 Le Barp, France</EM>
<BR>
Jean-Jacques Pesqu&#233;
<BR><EM>CEA/CESTA, BP 2, 33114 Le Barp, France</EM>
<BR>
Jean Roman
<BR><EM>INRIA Bordeaux Sud-Ouest and LaBRI, Universit&#233; de Bordeaux, Talence, France</EM>
</DIV>

<P>
Solving Maxwell equations using multigrid method is a well known
problem, and many approaches and solvers have been explored. In this
talk, we describe a specific
methodology for solving large linear systems arising from Maxwell
equations discretized with first-order N&#233;d&#233;lec elements. Using this
methodology, a new parallel solver is developed. This solver combines
the PaStiX parallel direct solver and full multigrid cycles. The goal
of this proposed method is to compute the solution for problems
defined on fine irregular meshes with minimal overhead costs when
compared to the cost of applying a classical direct solver on the
coarse mesh.

<P>
The PaStiX direct solver can handle linear systems with up to 100 million
unknowns, but this size is
limited by the computer memory, so that finer problem resolutions that
often occur in practice cannot be handled by this direct solver. The
aim of the new method is to provide a way to solve problems with up to
1&nbsp;billion unknowns, given an input mesh with up to 100 million
unknowns. The input mesh is used as the initial coarsest grid. Fine
meshes, where only smoothing sweeps are performed, will be generated
automatically. Such large problem size can be solved because the
matrix is assembled only on the coarsest mesh, while on the finer
meshes, multigrid cycles are performed matrix-free.

<P>
The problem is defined on a 3D domain, which might be a subdomain extracted
from a physical domain <IMG
 WIDTH="16" HEIGHT="14" ALIGN="BOTTOM" BORDER="0"
 SRC="img1.png"
 ALT="$ \Omega$"> using a domain decomposition technique. There
are two types of boundaries, giving rise to two types of boundary conditions,
an impedance condition on the inner, material interface
and a transmission condition on the outer interface.

<P>
In order to solve the differential equations, we use a tetrahedral
N&#233;d&#233;lec finite element discretization, leading to an irregular 3D
mesh. These elements are
edge-based, with the unknowns defined on the edges. These edge values
represent the electric field circulation along an oriented edge
<IMG
 WIDTH="20" HEIGHT="30" ALIGN="MIDDLE" BORDER="0"
 SRC="img2.png"
 ALT="$ \Gamma_i$"> with unit tangential vector <!-- MATH
 $\vec{\tau_i}$
 -->
<IMG
 WIDTH="17" HEIGHT="31" ALIGN="MIDDLE" BORDER="0"
 SRC="img3.png"
 ALT="$ \vec{\tau_i}$">, and they are
computed in each element with the formula
<BR>
<DIV ALIGN="CENTER">
<!-- MATH
 \begin{eqnarray*}
\alpha_i = \int_{\Gamma_i}{\vec E. \vec \tau_i} d{\Gamma_i}.
\end{eqnarray*}
 -->
<TABLE CELLPADDING="0" ALIGN="CENTER" WIDTH="100%">
<TR VALIGN="MIDDLE"><TD NOWRAP ALIGN="RIGHT"><IMG
 WIDTH="124" HEIGHT="53" ALIGN="MIDDLE" BORDER="0"
 SRC="img4.png"
 ALT="$\displaystyle \alpha_i = \int_{\Gamma_i}{\vec E. \vec \tau_i} d{\Gamma_i}.$"></TD>
<TD>&nbsp;</TD>
<TD>&nbsp;</TD>
<TD WIDTH=10 ALIGN="RIGHT">
&nbsp;</TD></TR>
</TABLE></DIV>
<BR CLEAR="ALL">

In each element, electric field interpolation <IMG
 WIDTH="17" HEIGHT="18" ALIGN="BOTTOM" BORDER="0"
 SRC="img5.png"
 ALT="$ \hat{E}$"> is achieved
using the natural linear vectorial basis function <IMG
 WIDTH="18" HEIGHT="30" ALIGN="MIDDLE" BORDER="0"
 SRC="img6.png"
 ALT="$ p_i$">
<BR>
<DIV ALIGN="CENTER">
<!-- MATH
 \begin{eqnarray*}
\int_{\Gamma_j}{\vec p_i. \vec \tau_j} d{\Gamma_j}
&=& 0 \textrm{ for } \Gamma_{j \neq i} \\
&=& 1 \textrm{ for } \Gamma_{j=i},\\
\hat{E}(x,y,z) &=& \sum_{i=1}^{6}{ \vec{p_i}(x,y,z).\alpha_i}.
\end{eqnarray*}
 -->
<TABLE CELLPADDING="0" ALIGN="CENTER" WIDTH="100%">
<TR VALIGN="MIDDLE"><TD NOWRAP ALIGN="RIGHT"><IMG
 WIDTH="87" HEIGHT="53" ALIGN="MIDDLE" BORDER="0"
 SRC="img7.png"
 ALT="$\displaystyle \int_{\Gamma_j}{\vec p_i. \vec \tau_j} d{\Gamma_j}$"></TD>
<TD WIDTH="10" ALIGN="CENTER" NOWRAP><IMG
 WIDTH="17" HEIGHT="30" ALIGN="MIDDLE" BORDER="0"
 SRC="img8.png"
 ALT="$\displaystyle =$"></TD>
<TD ALIGN="LEFT" NOWRAP><IMG
 WIDTH="73" HEIGHT="30" ALIGN="MIDDLE" BORDER="0"
 SRC="img9.png"
 ALT="$\displaystyle 0 \textrm{ for } \Gamma_{j \neq i}$"></TD>
<TD WIDTH=10 ALIGN="RIGHT">
&nbsp;</TD></TR>
<TR VALIGN="MIDDLE"><TD NOWRAP ALIGN="RIGHT">&nbsp;</TD>
<TD WIDTH="10" ALIGN="CENTER" NOWRAP><IMG
 WIDTH="17" HEIGHT="30" ALIGN="MIDDLE" BORDER="0"
 SRC="img8.png"
 ALT="$\displaystyle =$"></TD>
<TD ALIGN="LEFT" NOWRAP><IMG
 WIDTH="77" HEIGHT="30" ALIGN="MIDDLE" BORDER="0"
 SRC="img10.png"
 ALT="$\displaystyle 1 \textrm{ for } \Gamma_{j=i},$"></TD>
<TD WIDTH=10 ALIGN="RIGHT">
&nbsp;</TD></TR>
<TR VALIGN="MIDDLE"><TD NOWRAP ALIGN="RIGHT"><IMG
 WIDTH="69" HEIGHT="38" ALIGN="MIDDLE" BORDER="0"
 SRC="img11.png"
 ALT="$\displaystyle \hat{E}(x,y,z)$"></TD>
<TD WIDTH="10" ALIGN="CENTER" NOWRAP><IMG
 WIDTH="17" HEIGHT="30" ALIGN="MIDDLE" BORDER="0"
 SRC="img8.png"
 ALT="$\displaystyle =$"></TD>
<TD ALIGN="LEFT" NOWRAP><IMG
 WIDTH="120" HEIGHT="67" ALIGN="MIDDLE" BORDER="0"
 SRC="img12.png"
 ALT="$\displaystyle \sum_{i=1}^{6}{ \vec{p_i}(x,y,z).\alpha_i}.$"></TD>
<TD WIDTH=10 ALIGN="RIGHT">
&nbsp;</TD></TR>
</TABLE></DIV>
<BR CLEAR="ALL">

<P>
With these components, we can show that mesh refinement is numerically
simple, and two regular refinement methods can be used. The
first refinement method uses the gravity center as a new vertex,
creating 4 new tetrahedrons. The new edge values, computed using
N&#233;d&#233;lec basis functions, are simply weighted sums of the coarser
edge values, which are not modified by this refinement procedure. The second method
splits each tetrahedron edge. As a consequence, the coarsening phase
for this second method is more complicated and may require more memory
storage to keep vectors on all mesh levels. Furthermore, in this
second method, for each coarse tetrahedron, 8 new ones are created,
which means that problem size grows fast on each refinement level. Because of
this growth, we use the first refinement method.

<P>
The first step of our method is to solve the problem on the coarsest
input mesh using the PaStiX parallel direct solver. On this coarsest
level, the system is formed by assembling the global matrix using the
elementary matrices. This complex but symmetric matrix is then
factorized and solved. Next, the computed solution is prolongated onto
a finer mesh using the technique described above. On this finer
mesh, a multigrid V-cycle is used to damp out the interpolation error
and capture fine-scale solution features.

<P>
Choosing the smoother in the V-cycle is crucial. Such method must
smooth the error in a few sweeps, and must also be efficient and
parallelizable. Moreover, in order to be matrix-free, the smoother
must be realized using only matrix-vector products. Currently, we plan
to use Gauss-Jacobi type smoothers.

<P>
Since the input is the coarsest mesh, the depth of the multigrid cycle
is determined by this original mesh level. In the V-cycle, once the
coarsest refinement level is reached, a direct solve is performed
using the factorized matrix already computed. As a consequence,
solving the coarsest level system requires only a forward-backward
solve phase. Naturally, reaching this coarse level is not always
necessary if the desired accuracy has already been attained.

<P>
The main advantage of this method is that the coarsest level matrix
only needs to be assembled, and its factorization is done only once
(since we use a regular refinement procedure, the coarsest level
matrix is unchanged). Factorization performed by the first PaStiX
invocation can be viewed as a preprocessing stage, piloting the
parallel aspects of the solution phase by distributing the matrix and elements
over processors. All solves after the parallel factorization are
performed with a complexity equivalent to a forward-backward
solve, which is highly dependent on the renumbering of the unknowns performed
before the factorization.

<P>
Another advantage of this method is related to the mesh. In
classical Maxwell problems, the mesh must meet two
requirements. It must physically describe the problem and it must
satisfy a wavelength restriction that ensures that elements are
small enough to capture the applied wavelength. In this approach, the
input mesh must fulfill the first requirement, while the second one
only applies to the fine mesh and is progressively ensured by
successive refinements. From this specificity arises one main
advantage of this method. Studying a given object at increasing high
frequencies requires a unique initial mesh describing problem geometry
while wavelength requirements are met by using deeper V-cycles.

<P>
<BR><HR>
<!--Table of Child-Links-->
<A NAME="CHILD_LINKS"></A>

<UL>
<LI><A NAME="tex2html4"
  HREF="node1.html">About this document ...</A>
</UL>
<!--End of Table of Child-Links-->
<HR>
<!--Navigation Panel-->
<A NAME="tex2html2"
  HREF="node1.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next"
 SRC="file:/usr/share/latex2html/icons/next.png"></A> 
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up"
 SRC="file:/usr/share/latex2html/icons/up_g.png"> 
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous"
 SRC="file:/usr/share/latex2html/icons/prev_g.png">   
<BR>
<B> Next:</B> <A NAME="tex2html3"
  HREF="node1.html">About this document ...</A>
<!--End of Navigation Panel-->
<ADDRESS>
Marian
2009-02-04
</ADDRESS>
</BODY>
</HTML>
